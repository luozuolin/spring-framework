#搞懂分布式技术1：分布式系统的一些基本概念
#分布式系统
分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统
##1.CAP
CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这三个基本需求，最多只能同时满足其中的2个
##2.BASE
BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。
##3.分布式事务
###3.1本地消息
1. 原理
本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。

在分布式事务操作的一方，它完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
2. 分析
本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。
##3.2分布式锁
1. 数据库的唯一索引
当想要获得锁时，就向表中插入一条记录，释放锁时就删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。
这种方式存在以下几个问题：
锁没有失效时间，解锁失败会导致死锁，其他线程无法再获得锁。
只能是非阻塞锁，插入失败直接就报错了，无法重试。
不可重入，同一线程在没有释放锁之前无法再获得锁。
https://blog.csdn.net/lovexiaotaozi/article/details/83819916
2. Redis 的 SETNX 指令
使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。

SETNX 指令和数据库的唯一索引类似，可以保证只存在一个 Key 的键值对，可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。

EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了死锁的发生。
3. Redis 的 RedLock 算法
使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。
计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了。
如果锁获取失败，会到每个实例上释放锁。
4. Zookeeper 的有序节点 ？？？
暂时不会
##4 分布式 Session
在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。
1. Sticky Sessions
通过使每个用户每访问的服务端实例为同一个来确保session的正常使用
缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。
将同一个用户的请求转发到同一台服务器，避免session失效。常见的有F5物理负载均衡，nginx的ip_hash等。
https://blog.csdn.net/tomcat_baby/article/details/52787679
2. Session Replication
通过各个服务端实例之间的session复制，来确保每个服务端实例均具有session中的信息，以达到session的一致性
缺点：需要更好的服务器硬件条件；需要对服务器进行配置。
tomcat的session复制共享
3. Persistent DataStore
将 Session 信息持久化到一个数据库中。
缺点：有可能需要去实现存取 Session 的代码。
4.会话第三方管理
通过redis等第三方的工具来存储session信息，使所有服务器实例均能访问到相同的session
缺点：有可能需要去实现存取 Session 的代码。
##5 负载均衡
###5.1算法
1. 轮询（Round Robin）
轮询算法把每个请求轮流发送到每个服务器上
2. 加权轮询（Weighted Round Robbin）
加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。
3. 最少连接（least Connections）
最少连接算法就是将请求发送给当前最少连接数的服务器上。
4. 加权最少连接（Weighted Least Connection）
在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。
5. 随机算法（Random）
把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。
6. 源地址哈希法 (IP Hash)
源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。

优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。
缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。
###5.2 实现
1. HTTP 重定向
HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。
缺点：
用户访问的延迟会增加；
如果负载均衡器宕机，就无法访问该站点。
2. DNS 重定向
使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。
缺点：
DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。
3. 修改 MAC 地址
使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。
4. 修改 IP 地址
在网络层修改请求的目的 IP 地址
5. 代理自动配置
正向代理与反向代理的区别：

正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。
反向代理：发生在服务器端，用户不知道代理的存在。
PAC 服务器是用来判断一个请求是否要经过代理。
##6 高可用之“脑裂”
当两（多）个节点同时认为自已是唯一处于活动状态的服务器从而出现争用资源的情况，这种争用资源的场景即是所谓的“脑裂”（split-brain）或”区间集群“（partitioned cluster）

